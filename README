OE Signatures
-------------

This bitbake layer (OpenEmbedded Overlay) exists to test some code which I've
thrown together.  This code changes the way variables are expanded, to allow
more information to be retained easily about what it references.  It also adds
tracking of what shell functions are called by other shell functions, and what
variables are used from the metadata by python code.

There are multiple purposes of this, but the most immediate is to implement
intelligent signature/hash generation of the metadata (or chunks of the
metadata).  This is necessary in order to provide sane binary caching support,
and in the future, will allow bitbake to move away from the "stamp" concept
entirely, instead relying on tracking of the input and output of tasks, and
the pieces of the metadata they use.

Next, this should allow us, in the long term, to allow one to edit a
configuration file without reparsing the world.  Of course, Holger's ast work
is a step in the right direction for that also, but this would allow us to
bypass re-execution of the ast statements as well, simply letting 'dirty'
state information flow through the variable references.

Known Issues / Concerns:
- No recursion checking yet.
- It has to expand the shell and python code in order to scan it to extract
  the variable reference information.  In some cases, this means the expansion
  may be occurring sooner than it would normally expect to happen.  As an
  example, a variable which runs a function in a ${@} snippet that reads from
  a file in staging -- this will not be happy if expanded before the task is
  actually to be run.  It may be that we'll want to avoid this sort of thing,
  as it also causes problems with bitbake -e.
- Currently it pays zero attention to flags, as flags generally instruct
  bitbake in *how* to make something happen, not *what* will happen, for a
  given task.
- ShellValue
  - The shell code which identifies defined functions and excludes them from
    the list of executed commands does not take into account context.  If one
    defined a function in a subshell, it would still exclude it from the list.
  - Cannot currently determine what variable (if a variable) is being
    referenced if it's a shell variable expansion.  As an example: 'for x in 1
    2 3; eval $x; done'
- PythonValue:
  - Cannot determine what variable is being referenced when the argument to
    the getVar is something other than a literal string.  As an example,
    '"RDEPENDS_" + pkg' bites us.
  - Does not exclude locally imported functions from the list of executed
    functions.  If you run 'from collections import defaultdict', and run
    defaultdict, it will include defaultdict in the list of executed
    functions.  We should check for those import statements.
  - It captures a list of functions which are executed directly (that is,
    they're names, not attributes), but does not exclude functions which are
    actually defined in this same block of code.  We should try to do so,
    though it will be difficult to be full proof without taking into account
    contexts.

TODO:
  - Add checking for recursion
  - Create a Signature class to wrap up the various methods used to
    construct it, and to make it easier to access the hash digest, the
    base64 encoded string, and the actual data used to produce the hash,
    which is useful for debugging.

  - Cleanup
    - Fix up the exception handling and bb.msg output
    - In the overridden references methods, use a uniq() utility function or a
      set to drop duplicates between the superclass references and the extra
      references gathered by the class.
    - Sanitize the property names amongst the Value implementations
    - Should the 'references' method become a property?
    - Rename 'references', as it is specifically references to variables in
      the metadata.  This isn't the only type of reference we have anymore, as
      we'll also be tracking calls to the methods in the methodpool.

  - Performance
    - Add memoization of __str__, ideally indexed by the bits that feed into
      the resulting string (i.e. self.components).

  - PythonValue:
    - Move the direct function call list from the visitor into the main object
      after parsing, so the caller doesn't need to poke into the visitor
      directly.
    - Think about checking imports to exclude more direct func calls
